// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateUpdate {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createUpdate(data: UpdateCreateInput!): Update!
  updateUpdate(data: UpdateUpdateInput!, where: UpdateWhereUniqueInput!): Update
  updateManyUpdates(data: UpdateUpdateManyMutationInput!, where: UpdateWhereInput): BatchPayload!
  upsertUpdate(where: UpdateWhereUniqueInput!, create: UpdateCreateInput!, update: UpdateUpdateInput!): Update!
  deleteUpdate(where: UpdateWhereUniqueInput!): Update
  deleteManyUpdates(where: UpdateWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  update(where: UpdateWhereUniqueInput!): Update
  updates(where: UpdateWhereInput, orderBy: UpdateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Update]!
  updatesConnection(where: UpdateWhereInput, orderBy: UpdateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UpdateConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  SUPERADMIN
  ADMIN
  BASIC
  NONE
}

enum Status {
  ACTIVE
  IDLE
}

type Subscription {
  update(where: UpdateSubscriptionWhereInput): UpdateSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Update {
  id: ID!
  user: User!
  date: DateTime!
}

type UpdateConnection {
  pageInfo: PageInfo!
  edges: [UpdateEdge]!
  aggregate: AggregateUpdate!
}

input UpdateCreateInput {
  id: ID
  user: UserCreateOneWithoutUpdatesInput!
  date: DateTime!
}

input UpdateCreateManyWithoutUserInput {
  create: [UpdateCreateWithoutUserInput!]
  connect: [UpdateWhereUniqueInput!]
}

input UpdateCreateWithoutUserInput {
  id: ID
  date: DateTime!
}

type UpdateEdge {
  node: Update!
  cursor: String!
}

enum UpdateOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
}

type UpdatePreviousValues {
  id: ID!
  date: DateTime!
}

input UpdateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [UpdateScalarWhereInput!]
  OR: [UpdateScalarWhereInput!]
  NOT: [UpdateScalarWhereInput!]
}

type UpdateSubscriptionPayload {
  mutation: MutationType!
  node: Update
  updatedFields: [String!]
  previousValues: UpdatePreviousValues
}

input UpdateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UpdateWhereInput
  AND: [UpdateSubscriptionWhereInput!]
  OR: [UpdateSubscriptionWhereInput!]
  NOT: [UpdateSubscriptionWhereInput!]
}

input UpdateUpdateInput {
  user: UserUpdateOneRequiredWithoutUpdatesInput
  date: DateTime
}

input UpdateUpdateManyDataInput {
  date: DateTime
}

input UpdateUpdateManyMutationInput {
  date: DateTime
}

input UpdateUpdateManyWithoutUserInput {
  create: [UpdateCreateWithoutUserInput!]
  delete: [UpdateWhereUniqueInput!]
  connect: [UpdateWhereUniqueInput!]
  set: [UpdateWhereUniqueInput!]
  disconnect: [UpdateWhereUniqueInput!]
  update: [UpdateUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UpdateUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [UpdateScalarWhereInput!]
  updateMany: [UpdateUpdateManyWithWhereNestedInput!]
}

input UpdateUpdateManyWithWhereNestedInput {
  where: UpdateScalarWhereInput!
  data: UpdateUpdateManyDataInput!
}

input UpdateUpdateWithoutUserDataInput {
  date: DateTime
}

input UpdateUpdateWithWhereUniqueWithoutUserInput {
  where: UpdateWhereUniqueInput!
  data: UpdateUpdateWithoutUserDataInput!
}

input UpdateUpsertWithWhereUniqueWithoutUserInput {
  where: UpdateWhereUniqueInput!
  update: UpdateUpdateWithoutUserDataInput!
  create: UpdateCreateWithoutUserInput!
}

input UpdateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [UpdateWhereInput!]
  OR: [UpdateWhereInput!]
  NOT: [UpdateWhereInput!]
}

input UpdateWhereUniqueInput {
  id: ID
}

type User {
  username: ID!
  createdAt: DateTime!
  firstname: String!
  surname: String!
  password: String!
  role: Role!
  status: Status!
  updates(where: UpdateWhereInput, orderBy: UpdateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Update!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  username: ID
  firstname: String!
  surname: String!
  password: String!
  role: Role
  status: Status
  updates: UpdateCreateManyWithoutUserInput
}

input UserCreateOneWithoutUpdatesInput {
  create: UserCreateWithoutUpdatesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutUpdatesInput {
  username: ID
  firstname: String!
  surname: String!
  password: String!
  role: Role
  status: Status
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  username_ASC
  username_DESC
  createdAt_ASC
  createdAt_DESC
  firstname_ASC
  firstname_DESC
  surname_ASC
  surname_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  status_ASC
  status_DESC
}

type UserPreviousValues {
  username: ID!
  createdAt: DateTime!
  firstname: String!
  surname: String!
  password: String!
  role: Role!
  status: Status!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  firstname: String
  surname: String
  password: String
  role: Role
  status: Status
  updates: UpdateUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  firstname: String
  surname: String
  password: String
  role: Role
  status: Status
}

input UserUpdateOneRequiredWithoutUpdatesInput {
  create: UserCreateWithoutUpdatesInput
  update: UserUpdateWithoutUpdatesDataInput
  upsert: UserUpsertWithoutUpdatesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutUpdatesDataInput {
  firstname: String
  surname: String
  password: String
  role: Role
  status: Status
}

input UserUpsertWithoutUpdatesInput {
  update: UserUpdateWithoutUpdatesDataInput!
  create: UserCreateWithoutUpdatesInput!
}

input UserWhereInput {
  username: ID
  username_not: ID
  username_in: [ID!]
  username_not_in: [ID!]
  username_lt: ID
  username_lte: ID
  username_gt: ID
  username_gte: ID
  username_contains: ID
  username_not_contains: ID
  username_starts_with: ID
  username_not_starts_with: ID
  username_ends_with: ID
  username_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  surname: String
  surname_not: String
  surname_in: [String!]
  surname_not_in: [String!]
  surname_lt: String
  surname_lte: String
  surname_gt: String
  surname_gte: String
  surname_contains: String
  surname_not_contains: String
  surname_starts_with: String
  surname_not_starts_with: String
  surname_ends_with: String
  surname_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  updates_every: UpdateWhereInput
  updates_some: UpdateWhereInput
  updates_none: UpdateWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  username: ID
}
`